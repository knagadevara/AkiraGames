package cliffhanger

import (
	"bufio"
	"fmt"
	"log"
	"os"
	"strings"

	"github.com/knagadevara/AkiraGames/utl"
)

type CountryApiResp struct {
	Error string    `json:"error"`
	Msg   string    `json:"msg"`
	Data  []Country `json:"data"`
}

type Country struct {
	Name    string `json:"name"`
	Capital string `json:"capital"`
	ISO2    string `json:"iso2"`
	ISO3    string `json:"iso3"`
}

type CountryIface interface {
	SetCountry() (Country, error)
	GetCountry() string
	GetCapital() string
	GetISO() string
}

type GameName string

type GameNameIface interface {
	SetGameName(name string) GameName
}

type CrypticWord string

type CrypticWordIface interface {
	SetCrypticWord(word GuessWord) CrypticWord
	CheckIfLetterExists(l LettersInWord, guessLetter Letter) CrypticWord
}

type GuessWord string

type GuessWordIface interface {
	SetGuessWord(c Country) GuessWord
}

type IsCorrect bool

type IsCorrectIface interface {
	SetIsCorrect(tf bool) IsCorrect
	CheckIfCorrect(cw CrypticWord) IsCorrect
}

type LettersInWord map[Letter][]int

type LettersInWordIface interface {
	SetLettersInWord(s string) LettersInWord
}

type Letter rune

type LetterIface interface {
	SetLetter() Letter
}

type TryCount int

type TryCountIface interface {
	SetTryCount(i int) TryCount
}

type PreviousLetters map[Letter]bool

type PreviousLettersIface interface {
	SetPreviousLetters(guessLetter Letter) PreviousLetters
}

type Cliffhanger interface {
	GameNameIface
	CountryIface
	CrypticWordIface
	GuessWordIface
	IsCorrectIface
	PreviousLettersIface
	TryCountIface
	LetterIface
	LettersInWordIface
	Start() *CliffhangerPlayerData
	GamePlay() *CliffhangerPlayerData
}

type CliffhangerPlayerData struct {
	Name                 GameName
	Country              Country
	CrypticWord          CrypticWord
	GuessWord            GuessWord
	IsCorrect            IsCorrect
	TryCount             TryCount
	CurrentGuessedLetter Letter
	LettersInWord        LettersInWord
	PreviousLetters      PreviousLetters
}

func (c Country) SetCountry() (Country, error) {
	apiBaseUrl := "https://countriesnow.space/api/"
	apiVersion := "v0.1"
	apiResource := "/countries/capital"
	resource_string := apiBaseUrl + apiVersion + apiResource
	CountryResp := utl.LoadGameData[CountryApiResp]("GET", resource_string, "/Users/snagadev/go/src/AkiraGames/StaticFiles/GameJSON/Countries.json")
	if CountryResp.Error != "" {
		return Country{}, fmt.Errorf("unable to get data: %s", CountryResp.Error)
	}
	return *utl.GetRandItem(CountryResp.Data), nil
}

func (c Country) GetCountry() string { return c.Name }
func (c Country) GetCapital() string { return c.Capital }
func (c Country) GetISO() string     { return c.ISO2 }

func (g GameName) SetGameName(name string) GameName {
	return GameName(name)
}

func (Is IsCorrect) SetIsCorrect(tf bool) IsCorrect {
	return IsCorrect(tf)
}

func (c CrypticWord) SetCrypticWord(word GuessWord) CrypticWord {
	tmpRunes := make([]rune, len(word))
	for i, v := range word {
		if v == ' ' {
			tmpRunes[i] = ' '
		} else {
			tmpRunes[i] = '_'
		}
	}
	return CrypticWord(tmpRunes)
}

func (g GuessWord) SetGuessWord(c Country) GuessWord {
	return GuessWord(c.Name)
}

func (Ic IsCorrect) CheckIfCorrect(cw CrypticWord) IsCorrect {
	if strings.ContainsRune(string(cw), '_') {
		return IsCorrect(false)
	}
	return IsCorrect(true)
}

func (l LettersInWord) SetLettersInWord(g GuessWord) LettersInWord {
	for ix, v := range g {
		l[Letter(v)] = append(l[Letter(v)], ix)
	}
	return l
}

func (crypt CrypticWord) CheckIfLetterExists(l LettersInWord, guessLetter Letter) CrypticWord {
	crossword := []Letter(crypt)
	ix, ok := l[guessLetter]
	if ok {
		for _, v := range ix {
			crossword[v] = guessLetter
		}
		return CrypticWord(crossword)
	}
	fmt.Println("Wrong Guess!!!")
	return crypt
}

func (pl PreviousLetters) SetPreviousLetters(guessLetter Letter) PreviousLetters {
	pl[guessLetter] = true
	return pl
}

func (bl TryCount) SetTryCount(i int) TryCount {
	return bl + TryCount(i)
}

func (l Letter) SetLetter() Letter {
	fmt.Printf("Please Input your Guess! :\t")
	inpRdr := bufio.NewReader(os.Stdin)
	return Letter(utl.GetRune()(inpRdr))
}

func (Cf CliffhangerPlayerData) DisplayGameState() *CliffhangerPlayerData {
	insigNia := "\t\t=====| * |=====\t\t"
	header := insigNia + "\t" + string(Cf.Name) + "\t" + insigNia
	footer := insigNia + " * + - | - + * " + insigNia
	fmt.Printf("%v", header)
	fmt.Printf("Guess Me??? >>>> %v", Cf.CrypticWord)
	fmt.Printf("%v", footer)
	return &Cf
}

func (Cf *CliffhangerPlayerData) Initiate() *CliffhangerPlayerData {
	Cf.Name = GameName("Cliffhanger").SetGameName("Cliffhanger")
	country, err := (&Country{}).SetCountry()
	if err != nil {
		log.Fatalln(err)
	}
	Cf.Country = country
	Cf.GuessWord = Cf.GuessWord.SetGuessWord(Cf.Country)
	Cf.LettersInWord = make(LettersInWord, len(Cf.GuessWord)).SetLettersInWord(Cf.GuessWord)
	Cf.IsCorrect = IsCorrect(false).SetIsCorrect(false)
	Cf.TryCount = TryCount(0).SetTryCount(0)
	Cf.CrypticWord = Cf.CrypticWord.SetCrypticWord(Cf.GuessWord)
	return Cf
}

func (Cf *CliffhangerPlayerData) GamePlay() {
	word := TryCount(len(Cf.CrypticWord))
	for !(Cf.IsCorrect) {
		Cf.DisplayGameState()
		Cf.CurrentGuessedLetter = Cf.CurrentGuessedLetter.SetLetter()
		Cf.CrypticWord = Cf.CrypticWord.CheckIfLetterExists(Cf.LettersInWord, Cf.CurrentGuessedLetter)
		Cf.PreviousLetters = Cf.PreviousLetters.SetPreviousLetters(Cf.CurrentGuessedLetter)
		Cf.IsCorrect = Cf.IsCorrect.CheckIfCorrect(Cf.CrypticWord)
		Cf.TryCount = Cf.TryCount.SetTryCount(1)
		if Cf.TryCount > word {
			break
		}
	}
}

func (Cf *CliffhangerPlayerData) Start() {
	Cf.Initiate().GamePlay()
}
